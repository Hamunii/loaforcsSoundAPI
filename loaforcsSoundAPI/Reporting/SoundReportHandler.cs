using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using BepInEx;
using BepInEx.Configuration;
using loaforcsSoundAPI.Core.JSON;
using loaforcsSoundAPI.Core.Util;
using loaforcsSoundAPI.Reporting.Data;
using loaforcsSoundAPI.SoundPacks;
using loaforcsSoundAPI.SoundPacks.Data;
using Newtonsoft.Json;
using UnityEngine;

namespace loaforcsSoundAPI.Reporting;

/// <summary>
/// Handles reports generated by SoundAPI for Sound-pack creators.
/// </summary>
public static class SoundReportHandler {
	/// <summary>
	/// Report currently being generated. Is null if SoundAPI is not generating a report.
	/// </summary>
	public static SoundReport CurrentReport { get; private set; }

	const string _datetimeFormat = "dd_MM_yyyy-HH_mm";

	static Action<StreamWriter, SoundReport> _reportSections = delegate { };

	/// <summary>
	/// Adds a custom report section to a generated report
	/// </summary>
	/// <param name="header">Description of section</param>
	/// <param name="callback">Callback when writing to file</param>
	public static void AddReportSection(string header, Action<StreamWriter, SoundReport> callback) {
		_reportSections += (stream, report) => {
			stream.WriteLine($"## {header}");
			callback(stream, report);
			stream.WriteLine("");
			stream.WriteLine("");
		};
	}
		
	internal static void Register() {
		Directory.CreateDirectory(GetFolder()); // make sure path exists.
		CurrentReport = new SoundReport();

		loaforcsSoundAPI.Logger.LogWarning("SoundAPI is generating a report!");
		loaforcsSoundAPI.Logger.LogInfo($"The report will be located at '{LogFormats.FormatFilePath(Path.Combine(GetFolder(), GetFileName(CurrentReport, ".md")))}");

		Application.quitting += () => {
			WriteReportToFile(CurrentReport);
		};

		SoundPackLoadPipeline.OnFinishedPipeline += () => {
			foreach(SoundPack pack in SoundPackDataHandler.LoadedPacks) {
				CurrentReport.SoundPackNames.Add(pack.Name);
			}
		};
		
		AddReportSection("General Information", (stream, report) => {
			stream.WriteLine($"SoundAPI version: `{MyPluginInfo.PLUGIN_VERSION}` <br/><br/>");
			
			stream.WriteLine($"Audio-clips loaded: `{report.AudioClipsLoaded}` <br/>");
			stream.WriteLine($"Match strings registered: `{SoundPackDataHandler.SoundReplacements.Values.Sum(it => it.Count)}` <br/>");
			
			WriteList("Loaded sound-packs", stream, report.SoundPackNames);
		});
		
		AddReportSection("Dynamic Data", (stream, _) => {
			if(SoundAPI.CurrentNetworkAdapter != null)
				stream.WriteLine($"Network Adapter: `{SoundAPI.CurrentNetworkAdapter.Name}` <br/><br/>");
			
			WriteList("Registered Conditions", stream, SoundPackDataHandler.conditionFactories.Keys.ToList());
		});
		
		AddReportSection("All Played Sounds", (stream, report) => {
			WriteList(null, stream, report.PlayedSounds.Select(it => it.FormatForReport()).ToList());
		});
	}

	internal static void Bind(ConfigFile file) {
		if (file.Bind("Developer", "GenerateReports", false, "While true SoundAPI will generate a json and markdown file per session that records information SoundAPI and related mods find.").Value) {
			Register();
		}
	}

	static string GetFileName(SoundReport report, string extension) {
		return $"generated_report-{report.StartedAt.ToString(_datetimeFormat)}{extension}";
	}

	static string GetFolder() {
		return Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "reports");
	}

	static void WriteReportToFile(SoundReport report) {
		using StreamWriter outputFile = new StreamWriter(Path.Combine(GetFolder(), GetFileName(report, ".md")));
		
		outputFile.WriteLine("# Generated Report");
		outputFile.WriteLine($"At {report.StartedAt} :3");
		outputFile.WriteLine("");

		_reportSections(outputFile, report);
		
		outputFile.Flush();
		outputFile.Close();
		
		using StreamWriter jsonFile = new StreamWriter(Path.Combine(GetFolder(), GetFileName(report, ".json")));
		jsonFile.WriteLine(JsonConvert.SerializeObject(report, Formatting.Indented));
	}

	public static void WriteList(string header, StreamWriter stream, ICollection<string> list) {
		if(!string.IsNullOrEmpty(header))
			stream.WriteLine($"### {header} (`{list.Count}`)");
		stream.WriteLine(string.Join("<br/>\n", list.Select(it => "- " + it)));
	}

	public static void WriteEnum<T>(string header, StreamWriter stream) where T : Enum {
		WriteList(header, stream, Enum.GetValues(typeof(T)).OfType<T>().Select(it => it.ToString().ToLowerInvariant()).ToList());
	}
}